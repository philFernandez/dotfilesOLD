#!/usr/bin/env bash
####################################
# fuzzy finder for manpages
# usage: fman <take no parameters> OR fman -p for preview mode
# depends on $HOME/.bin/cman for color output man pages
####################################

# Use embedded python3 script to walk through the manpath and extract
# all of the filenames
function get_manpages() {
all_programs=$(python3 << END

from os import walk
import re

def get_program_names(path_to_walk):
    files = []
    for (_, _, filenames) in walk(path_to_walk):
        files.extend(filenames)
    return files

def strip_file_extension(file_names):
    for index_of_file, file_name in enumerate(file_names):
        index_of_extension = file_name.rfind('.')
        file_names[index_of_file] = file_name[:index_of_extension]

def special_strip_file_extension(file_names):
    matchobj = re.compile(r'[a-z]\.\d$')
    for index, file_name in enumerate(file_names):
        if re.search(matchobj, file_name):
            index_of_extension = file_name.rfind('.')
            file_names[index] = file_name[:index_of_extension]

MAN_PATHS = [
        '/usr/share/man',
        '/usr/local/share/man',
        '/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/share/man',
        '/Library/Developer/CommandLineTools/usr/share/man'
        ]

PROGRAM_NAMES = []

for path in MAN_PATHS:
    PROGRAM_NAMES.extend(get_program_names(path))


strip_file_extension(PROGRAM_NAMES)

special_strip_file_extension(PROGRAM_NAMES)


PROGRAM_NAMES = set(PROGRAM_NAMES)
PROGRAM_NAMES = sorted(PROGRAM_NAMES)

for program in PROGRAM_NAMES:
    print(program)

END
)
echo "$all_programs"
}

function help_msg() {
  cat << EOF
usage: fman [-p] or [-s] {only one or zero options at a time}
-p <start in preview mode>            {optional}
-s <only show bookmarked manpages>    {optional}

press ctrl-s on a selected file to bookmark
EOF
}

HEADER="Fuzzy Man"
# Command that fzf will execute when enter is pressed on selected file
if [ -e "$HOME/.bin/cman" ] || [ -e "$HOME/bin/cman" ]; then
  CMD_TO_EXECUTE="LESS+='N' MANWIDTH=$(tput cols)% cman"
else
  CMD_TO_EXECUTE="LESS+='N' MANWIDTH=$(tput cols)% man"
fi

# if "-h" or "-p" is given we don't want to run get_manpages so we bypass
# that because it is not needed and is resource intensive.
if [ "$1" != "-h" ] && [ "$1" != "--h" ] && [ "$1" != "--help" ] && [ "$1" != "-s" ]; then
  # There are some duplicates between the directories so sort and filter
  ALL_MANPAGES=$(sort -u <<< "$(get_manpages)")
  # call man with all manpages piped to fzf
  if [ "$1" = "-p" ]; then # start in preview mode
    echo "$ALL_MANPAGES" | \
      fzf -i --reverse --header="$HEADER" \
      --preview="man {}" --preview-window="down:90%" \
      --prompt="man-> " --bind "enter:execute($CMD_TO_EXECUTE {})" \
      --bind "ctrl-s:execute(echo {} >> ~/.saved_manpages)"
  else # start without preview mode
    echo "$ALL_MANPAGES" | \
      fzf -i --reverse --header="$HEADER" \
      --prompt="man " --bind "enter:execute($CMD_TO_EXECUTE {})" \
      --bind "ctrl-s:execute(echo {} >> ~/.saved_manpages)"
  fi
# load up bookmark file if "-s" option is given
elif [ "$1" = '-s' ]; then
  cat ~/.saved_manpages | fzf -i --reverse --header="$HEADER {Bookmarks}" \
    --preview="man {}" --preview-window="down:90%" \
    --prompt="man-> " --bind "enter:execute($CMD_TO_EXECUTE {})" \
    --bind \
    "ctrl-d:execute(sed '/{}/d' ~/.saved_manpages > \
    ~/.tmp_save && /bin/mv -f ~/.tmp_save ~/.saved_manpages)"
else
  help_msg
fi
