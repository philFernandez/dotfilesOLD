#! /Users/philthy/Source_Code/Python/SqlApp/bin/python
from datetime import datetime
import sqlite3
from argparse import ArgumentParser
from Account import Account
import subprocess


def main():
    parser = ArgumentParser(add_help=False)
    parser.add_argument("-n", "--new", action="store_true")
    parser.add_argument("-u", "--user")
    parser.add_argument("-s", "--site")
    parser.add_argument("-k", "--key")
    parser.add_argument("-du", "--deluser")
    parser.add_argument("-ds", "--delsite")
    parser.add_argument("-dk", "--delkey")
    parser.add_argument("-h", "--help", action="store_true")

    # Catch argument errors and show help screen. this is needed
    # so that the program runs to finish and re-encrypts the database.
    # If the program experiences an argument error, and exits early, the
    # database will not be re-encrypted
    try:
        args = parser.parse_args()
        if args.new:
            insert()
        elif args.user:
            db_query('user', args.user)
        elif args.site:
            db_query('site', args.site)
        elif args.key:
            db_query('key', args.key)
        elif args.deluser:
            del_record('user', args.deluser)
        elif args.delsite:
            del_record('site', args.delsite)
        elif args.delkey:
            del_record('key', args.delkey)
        elif args.help:
            help_screen()
        else:
            print_db()
    except:  # redirect errors to help screen
        help_screen()


def insert():
    site = input("Enter Site Name: ")
    user = input("Enter User Name: ")
    key = input("Enter Key: ")
    date = datetime.now().utctimetuple()
    date_string = F"{date.tm_mon}/{date.tm_mday}/{date.tm_year}"
    time_string = F"{date.tm_hour}:{date.tm_min}"
    time = datetime.strptime(time_string, "%H:%M").strftime("%I:%M %p")
    time_stamp = F"{date_string} @ {time}"
    # Insert row into table
    try:
        c.execute(
            f"INSERT INTO passwords VALUES ('{site}', '{user}', '{key}', '{time_stamp}')")
        conn.commit()
    except sqlite3.OperationalError:
        print("""\
ERROR: Don't wrap input in quotes.
The record was not saved. Run the
program again. Input to program
must not contain quotes.""")


def db_query(query, query_item):
    search_key = (query_item,)
    c.execute(f'SELECT * FROM passwords WHERE {query}=?', search_key)
    db_hit = c.fetchall()
    for result in db_hit:
        account = Account(result)
        print(account)


def del_record(query, query_item):
    to_delete = (query_item,)
    try:
        c.execute(f'DELETE FROM passwords WHERE {query}=?', to_delete)
        conn.commit()
    except sqlite3.OperationalError:
        del_record(query, query_item)


def print_db():
    for row in c.execute('SELECT * FROM passwords'):
        account = Account(row)
        print(account)


def help_screen():
    print('''
usage: App.py [-h] [-n] [-u USER] [-s SITE] [-k KEY] [-du DELUSER] [-ds DELSITE] [-dk DELKEY]

optional arguments:
    -h, --help                      shot this help message and exit
    -n, --new                       add new account
    -u USER, -- USER                search user name
    -s SITE, --site SITE            search site name
    -k KEY, --key KEY               search pass key
    -du DELUSER, --deluser DELUSER  delete user
    -ds DELSITE, --delsite DELSITE  delete site
    -dk DELKEY, --delkey DELKEY     delete key
''')


# decrypt database file
subprocess.Popen('/Users/philthy/Source_Code/Python/SqlApp/secure.sh').wait()

# Open data base and create cursor globally
conn = sqlite3.connect('/Users/philthy/Source_Code/Python/SqlApp/data.db')
c = conn.cursor()
# Creat passwords table if it doesn't already exist
c.execute('''
CREATE TABLE IF NOT EXISTS passwords
(site name, user name, key, time_stamp)
''')

print()
main()
# close data base
conn.close()
# encrypt data base file
subprocess.Popen('/Users/philthy/Source_Code/Python/SqlApp/secure.sh').wait()
